Text Snippet Sharing Service
Pastebin のように、ユーザーがプレーンテキストやコードスニペットを共有できるオンラインコード＆テキストスニペット共有サービスを開発します。このプラットフォームは、ユーザーアカウントの必要がなく、簡単にテキストとコードを共有できるようにする必要があります。

ユーザーは、テキストエリアにテキストやコードを貼り付け、共有コンテンツの一意の URL が生成される機能を持たせる必要があります。この URL は、他の人とコンテンツを共有するために使用できます。一般的なプログラミング言語の構文のハイライトがコア機能として必要です。

機能要件

1. スニペットのアップロード
   ユーザーはテキストエリアにテキストやコードを貼り付けます。
   可読性を向上させるために、構文ハイライトを適用したいプログラミング言語を選択できます。
   ユーザーが内容を送信すると、スニペット用の一意の URL が生成されます。URL は一意の文字列に基づいています。フォーマットは、https://{domain}/{path}/{unique-string} のような形で、URL のパースには、例えば parse_url のようなライブラリを活用することが可能です。

2. スニペットの閲覧
   一意の URL にアクセスしてスニペットを閲覧できます。
   コードの場合、提出時に選択した言語に基づいてシンタックスハイライトを適用します。

3. スニペットの有効期限設定
   スニペットの有効期限（例：10 分、1 時間、1 日、永続）を設定するオプションを持ちます。
   期限切れになったスニペットは自動的に削除され、「Expired Snippet」というメッセージを表示します。

4. データストレージ
   バックエンドへ送信される全てのユーザーからの入力は、厳格に検証とサニタイズが行われる必要があります。
   SQL インジェクションを防ぐために、スニペットは安全に保存します。

5. フロントエンドインターフェース
   シンプルで使いやすいインターフェースを持ち、テキストまたはコードの送信を容易にします。
   スニペットが成功して送信されると、その内容にアクセスできる一意の URL が生成され、ユーザーに表示されます。

6. エラーハンドリング
   大量のテキストやコード、またはサポートされていない文字が送信された場合でも、適切に処理し、エラーメッセージを表示します。

技術要件

ウェブインターフェース
フロントエンドのデザインには HTML/CSS を使用します。
ダイナミックなインタラクションには JavaScript を利用します。
テキストやコード入力に monaco エディタの使用を検討します。

バックエンド
スニペットの送信、URL の生成、スニペットの提供を処理するために、静的型付けが可能なサーバサイドの OOP 言語、例えば PHP 8.0 を使用します。
一意の URL 生成には、hash()のようなハッシュ関数を利用します。

データベース
提出されたスニペット、それらの URL、ハイライト用のプログラム言語、送信時刻、有効期限を記録するために MySQL を使用します。

ミドルウェア
必要なすべてのデータベーススキーマをセットアップするためのマイグレーション管理システムを使用します。
データベースとのインタラクションには MySQLWrapper クラスを採用します。

非機能要件

デプロイメント
サービスは、ユーザーが簡単に記憶できるドメインやサブドメインで公開する必要があります。
サービスが常に利用可能で、サービスが利用できない時間が極力少ない状態を保つ必要があります。
エンジニアが迅速に開発とデプロイを行えるように、リポジトリ同期の Git コマンドを実行するだけでコードの更新と同期がライブで行える必要があります。

パフォーマンス
スニペットを効率よく取得し、ユーザーが迅速に閲覧できるようにする必要があります。
ページの読み込みが極端に遅くなることなく、速やかに構文ハイライトを表示できるようにします。

スケーラビリティ
大量のスニペットが同時に送信されても、それらをスムーズに処理できるシステムを確立する必要があります。

セキュリティ
スニペットは安全に保存され、不正アクセスを防ぐ仕組みを整える必要があります。
安全な接続とデータの暗号化を保証するために、HTTPS を採用する必要があります。

---

monaco エディターをブラウザに貼っつける
↓
スニペットの送信ボタン,送信内容を console に表示できるようにする
↓
monaco editor の input どうやって取得するんだ?
gpt に聞く
doc を見る->そもそも doc の見方を調べる
続き
どうやって取得するかは gpt に聞いた。
↓

Monaco Editor でユーザーが入力したコードを取得するには、editor.getValue()メソッドを使用します。このメソッドは、現在のエディターの内容を取得します。

この例では、Monaco Editor でユーザーが入力したコードを取得するために、editor.getValue()メソッドを使っています。ユーザーが入力したコードは userCode 変数に格納され、それを使って任意の処理を行うことができます。

```javascript
// Monaco Editorを初期化する
var editor = monaco.editor.create(document.getElementById("editor"), {
  value: 'console.log("Hello, Monaco Editor!");',
  language: "javascript",
  theme: "vs-dark", // テーマを選択する（例：'vs', 'vs-dark', 'hc-black'など）
});

// sendボタンの要素を取得する
var sendButton = document.getElementById("sendButton");

// sendボタンがクリックされた時の処理を追加する
sendButton.addEventListener("click", function () {
  // ユーザーが入力したコードを取得する
  var userCode = editor.getValue();
  // userCodeを使って何か処理を行う（例：サーバーに送信する、ローカルで実行するなど）
  console.log("User code:", userCode);
});
```

続き
value 取得できたから、php に送信してみる。
そもそもなぜ処理をサーバーに送信しなきゃいけないんだっけ?js と db だけだとダメなの?gpt に聞いてみる

f データを送信する
b データを検証して受け取る
bDB に追加する(後からユーザーがスニペット一覧を見れるようにするため、スニペットの有効期限を設定して期限が過ぎたら expire と表示させるため)
bURL を生成して返す
fURL を受け取る

続き
これらのデータのやり取りを見て、send,receive 関数を作るのかとかどうやってデータのやり取りを書くのかとかを調べる
m0

client
input を送信する
server
受け取る、検証、DB に追加、url を生成、それを送信
client
url を表示する

今
ちゃんとクライアントのデータをサーバーで取得できた。
次はそのデータを検証して DB に入れる。
ってことは検証のコードと DB のスキーマを考える。
今のゴール
node と DB を繋げて、データを入れる

一旦 push する。通信ができたコードを。そして db に入る。
今
mysql 接続でエラーが起こっている。その原因は多分 root で実行しているからだと思う。
今
mysql のユーザーを(snippet)変えて、データベースも snippet_db にしたけどまだエラーが残っている。

code: 'ER_NOT_SUPPORTED_AUTH_MODE',
errno: 1251,
sqlMessage: 'Client does not support authentication protocol requested by server; consider upgrading MySQL client',
sqlState: '08004',
fatal: true

ユーザー設定で with を追加してみる

ALTER USER 'snippet'@'localhost' IDENTIFIED WITH mysql_native_password BY 'wmkm0511';
↑
with をつけて接続する事ができた。

次のゴール
クライアントデータを db に入れて、コマンドで db 内に入っているか確認する。
db にデータ入ってた!
+------+-------------------------+
| id | content |
+------+-------------------------+
| NULL | //Hello, Monaco Editor! |
| NULL | //Hello, Monaco Editor! |
+------+-------------------------+
2 rows in set (0.00 sec)

db に入っているデータをサーバーで取得できた。
続き ↓
次はそれをクライアントに送ってブラウザに表示する(ブラウザにただ表示するのではなく、他の方法で表示すると思う。詳しくは recursion の上に書いてあるルールを見て!)
格納したデータを取ってきて、parse_url ライブラリで表示する。

client:

- "your new snippet has been posted at {url}"を表示する
- show all snippets button を実装する

今
まず show all snippets を表示したほうが簡単そう。
ルートではなく、今までの下に全部表示する
続き
contents の html 要素、ボタンを取得、関数内に append して html 要素を追加。
↓
button を押してみる。

ミドルウェア関連のエラーが出てきた。そして自分はミドルウェアに関して何も知らない。だから、まずミドルウェアについて学ぶ必要がある。そして server.js,db.js にそれぞれどんな役割をするコードを書けば良いのか定義してからコードを書き直す。今までミドルウェアの知識なしでうまく行っていたのはなぜかわからないけど、とりあえず学んでもう一度、送信ボタンをまずうまく実装できるようにする。
↓
まず前までうまく行っていたんだから、まず送信ボタンをちゃんと実装できるようにする。
↓
ちゃんと connection をエクスポートしているのに、query が使えないといエラーが起こっている。
↓
gpt に投げたから、それを読んで実行する。できたら次の show all も実装する。
↓
変数のエクスポートのエラーは解消できた。次は show all snippets をやっていく。
今
クリックされたら server が db からデータを取ってくる。それをクライアントに送信する。どのように書けば良いんだろう。という質問を gdp に投げたからそれを読んで実装する。ルートは同じでもいいと思うよ。
client: fetch してくる
server: クエリを書いて、db からデータを取ってくる。
↓
続き
クリックされたらどうやって実行されるのか、ちゃんとコードを追って調べる。
リクエストが post と get の場合でエンドポイントを分ければ、データをちゃんと取ってくる事ができる。

show all は、/all の URL に移動して表示させる。
今は、all.html に移動させたから fetch の root と違うからエラーが起きている。
続き fetch の URL を/all に変更する。

リファクタリングの時に/all とかを作る。いちいち root を変える作業をしていたら、時間がかかるだろうし。
↓
今日やること:

- send -> "your snippet is successfully saved!(link here)"
  key をつけて送信する。
  そもそもなぜ key が必要なのか自分で理解する
  うーん。自分で考えた方がもっと簡単に実装できるかも。
  parse_url というライブラリはないが、ランダムな文字列を生成してそれを localhost の root の後に追加するというやり方ならできる。
  そのランダムな文字列とデータを db で一緒に管理する必要がある。(link がシェアされた時に、その key の value を表示する事ができるから。)
  ////////////////////////////////////////////////
  //フェーズ 01//
  client: {ランダムな数字: userInput}で送信//done!
  server: {ランダムな数字: userInput}を DB に送信する
  db: テーブルに{key:値}が成立するように保存する
  //フェーズ 02//
  server: {key:値}どっちも取ってくる
  client: succeesufuly のメッセージを出して"localost"+key
  　　　　　/key には、hashmap[key]を表示する。
  ↑hashmap = [];
  db.departments.contents[0]//配列ではないから取れない。
  だから hashmap を定義して、Object.keys(result)[0]とかで取ってこれる。
  ↑ 確かどっかに書いた気がする github の CSnote を見てみる。
  ////////////////////////////////////////////////
  続き
  実際に送信してみる。
  そこからエラーが出るから、server を調節して DB も作っていく。
  {userInput:randomURL}として送信しているから、db のテーブル contents のみでいけるのではないか?取り出す時に json 形式に戻せば良いだけだから。
  ↑ もう一度全手順を追って、それで問題がないか確かめる。
  続き
  random がそうしても表示されない。なんでなのか原因を探る。

いけた!
次はとりあえず contents のみ表示できるようにする。
↓
show all button を押したらエラーが発生した。

//続き
これを見れば原因がわかると思う。

SyntaxError: Unexpected token / in JSON at position 0
データはこれ
{"content":"{\"userInput\":\"//Hello, Monaco Editor!\",\"random\":10}"}]

ChatGPT
このエラーは、JSON 形式として解析しようとしたときに予期しないトークン（Unexpected token）が見つかったことを示しています。具体的には、データが正しい JSON 形式ではない可能性があります。データの内容を見てみると、content がダブルクオートで囲まれた JSON 文字列になっているようです。正しい JSON 形式では、content の値は JSON オブジェクトである必要があります。

正しい JSON 形式にするためには、content の値を JSON オブジェクトに変更する必要があります。例えば、以下のように修正します。

json
Copy code
{"content":{"userInput":"//Hello, Monaco Editor!","random":10}}
このように修正すると、JSON として正しい形式になります。その後、このデータを解析する際には SyntaxError が発生しなくなります。

↓
多分 json 形式で db に送信しているからエラーが出るんだと思う。
だって db の content は違う型だから。
そう。
その前に json.stringfy と.parse をごっちゃにして書いてるけど違いわかってる?
↓
json.parse: 文字列->json へ
json.stringfy:json->文字列へ

# 同時進行 01 ↓

goal: json,文字列系のエラーを克服できた。今度は client の show ボタンを hello~から表示できるようにしたい。

その前にボタンを押した時のエラーを直す。

# 今!同時進行 02

random を 10 ではなく random な数字を使って送信できるようにする。
できたら git commit -m "send data randomURL and content"にする。
